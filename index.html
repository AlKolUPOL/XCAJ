<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Tool for Metacognitive Assessment</title>
    <style>
        /* Z치kladn칤 styl str치nky */
        body {
            font-family: 'Arial', sans-serif;
            background-color: #f0f4f8;
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden; /* Zabr치n칤 scrollov치n칤 cel칠 str치nky */
        }

        header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            text-align: center;
            font-size: 1.2em;
        }

        /* Hlavn칤 kontejner rozd캩luj칤c칤 obrazovku na dv캩 캜치sti */
        #main-container {
            display: flex;
            flex: 1;
            height: 100%;
        }

        /* LEV츼 캛츼ST: Pracovn칤 plocha (Experiment) */
        #workspace {
            flex: 2; /* Zab칤r치 2/3 코칤콏ky */
            background-color: #ffffff;
            border-right: 5px solid #ccc;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            position: relative;
        }

        /* PRAV츼 캛츼ST: Historie (Storehouse dle Veenmana) */
        #history-panel {
            flex: 1; /* Zab칤r치 1/3 코칤콏ky */
            background-color: #e8e8e8;
            display: flex;
            flex-direction: column;
            border-left: 1px solid #999;
        }

        #history-header {
            background-color: #dcdcdc;
            padding: 10px;
            text-align: center;
            font-weight: bold;
            border-bottom: 2px solid #aaa;
        }

        /* Zde se bude scrollovat - kl칤캜ov칠 pro m캩콏en칤 metakognice */
        #history-list {
            flex: 1;
            overflow-y: auto; /* Umo쬹칤 scrollov치n칤 */
            padding: 10px;
        }

        /* Styl pro samotn칠 pl치tno (Canvas) */
        #graph-canvas {
            border: 2px dashed #333;
            background-color: #fafafa;
            cursor: crosshair;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        /* Ovl치dac칤 tla캜칤tka */
        .controls {
            display: flex;
            gap: 15px;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .btn-test { background-color: #27ae60; color: white; font-weight: bold; }
        .btn-test:hover { background-color: #219150; }
        
        .btn-clear { background-color: #e74c3c; color: white; }
        .btn-clear:hover { background-color: #c0392b; }

        /* Uk치zka polo쬶y v historii (zat칤m jen statick치) */
        .history-item {
            background: white;
            border: 1px solid #ccc;
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 4px;
        }
        .history-item strong { display: block; margin-bottom: 5px; }

/* Nov칠 styly pro obr치zky v historii */
        .history-img {
            width: 100%;       /* Rozt치hnout na celou 코칤콏ku panelu */
            height: auto;
            border: 1px solid #ccc;
            margin-top: 5px;
            background-color: white;
        }
        .status-ok { color: green; font-weight: bold; }
        .status-fail { color: red; font-weight: bold; }

    </style>
</head>
<body>

    <header>
        Mystery: Which shapes can be drawn in one stroke?
    </header>

    <div id="main-container">
        
        <div id="workspace">
            <h3>Your Canvas</h3>
            <canvas id="graph-canvas" width="600" height="400"></canvas>
            
		<div class="controls">
                <button class="btn-clear" onclick="undoLastStep()" id="btn-undo" style="background:#888; color:white;">Undo</button> 
                <button class="btn-clear" onclick="clearGraph()">Clear All</button>
                <button class="btn-test" onclick="testGraph()">Test Image</button>
            </div>
            <div style="margin-top: 10px; display: flex; gap: 10px;">
                <button onclick="exportLog()" style="background:#3498db; color:white;">游 Download DATA</button>
                <button onclick="exportVisualReport()" style="background:#3498db; color:white;">游닝 Download REPORT</button>
            </div>

            <p><i>Click for a node. To connect, click one node and then another.</i></p>
        </div>

        <div id="history-panel">
            <div id="history-header">Your past attempts</div>
            <div id="history-list">
                <div class="history-item">
                    <strong>Pokus 캜. 0 (Sample)</strong>
                    Result: <span style="color:green">PASS</span><br>
                    <small>Thinking Time: --</small>
                </div>
            </div>
        </div>

    </div>

<script>
    // --- 1. PROM캨NN칄 (Tady se ukl치d치 stav grafu) ---
    const canvas = document.getElementById('graph-canvas');
    const ctx = canvas.getContext('2d');

    let nodes = []; // Seznam vrchol콢: {id, x, y}
    let edges = []; // Seznam hran: {from: id, to: id}
	let selectedNode = null; // Ukl치d치 uzel, na kter칳 se kliklo jako na prvn칤

    let history = []; 
    const MAX_HISTORY_STEPS = 20; 
    
    // Prom캩nn칠 pro ovl치d치n칤 my코i
    let isDragging = false;
    let dragStartNode = null;
    let mouseX = 0;
    let mouseY = 0;

// --- NOV칄 PROM캨NN칄 PRO LOGOV츼N칈 METAKOGNICE ---
    let metacognitionLog = []; // Hlavn칤 pole pro ukl치d치n칤 v코ech ud치lost칤 (logfile)
    let lastTestTimestamp = 0;   // 캛as, kdy bylo naposledy kliknuto OTESTOVAT (pro Thinktime)
    let previousGraphState = { nodesCount: 0, edgesCount: 0 }; // Ukl치d치me stav grafu po POSLEDN칈M testu (pro VOTAT)


    // --- FUNKCE PRO LOGOV츼N칈 ---
    // Tato funkce zaznamen치 ka쬯ou akci u쬴vatele a vypo캜칤t치 Thinktime
    function logAction(actionType, detail = {}) {
        const now = Date.now();
        
        let logEntry = {
            timestamp: now,
            action: actionType,
            nodes_count: nodes.length,
            edges_count: edges.length,
            ...detail,
            thinktime_ms: null
        };

        // KONTROLA THINKTIME
        // Pokud je lastTestTimestamp > 0, znamen치 to, 쬰 쮂멺 pr치v캩 provedl prvn칤 akci
        // po obdr쬰n칤 feedbacku (po testu).
        if (lastTestTimestamp > 0) {
            logEntry.thinktime_ms = now - lastTestTimestamp;
            lastTestTimestamp = 0; // Thinktime je spo캜칤t치n, vynulujeme
        }
        
        metacognitionLog.push(logEntry);
        // Voliteln칠 pro debug: console.log(logEntry);
    }

    // Nastaven칤 vzhledu
    const NODE_RADIUS = 15;
    const NODE_COLOR = '#3498db';
    const EDGE_COLOR = '#2c3e50';
    const HIGHLIGHT_COLOR = '#e74c3c'; // Barva p콏i ta쬰n칤

// Ulo쮂 aktu치ln칤 stav grafu do historie
    function saveState() {
        // Vytvo콏칤me hlubok칠 kopie (aby se nep콏episovaly referencemi)
        const newState = {
            nodes: JSON.parse(JSON.stringify(nodes)),
            edges: JSON.parse(JSON.stringify(edges))
        };
        
        history.push(newState);
        
        // Omezen칤 velikosti historie
        if (history.length > MAX_HISTORY_STEPS) {
            history.shift(); // Odstran칤me nejstar코칤 krok
        }
        
        updateUndoButtonState();
    }

// Obnov칤 p콏edchoz칤 stav z historie
    function undoLastStep() {
        if (history.length > 1) { 
            history.pop(); 
            const prevState = history[history.length - 1]; 
            
            // Zaji코t캩n칤 hlubok칠 kopie p콏i obnoven칤
            nodes = JSON.parse(JSON.stringify(prevState.nodes)); 
            edges = JSON.parse(JSON.stringify(prevState.edges)); 
            
            updateNodeDegrees(); 
            drawGraph();
            logAction('undo_action'); // <--- LOGOV츼N칈
        }
        updateUndoButtonState();
    }
    
    // Zm캩n칤 stav tla캜칤tka Undo
    function updateUndoButtonState() {
        const btn = document.getElementById('btn-undo');
        // Ponech치me tla캜칤tko aktivn칤, pokud m치me v칤ce ne 1 stav v historii (tzn. m콢쬰me se vr치tit zp캩t)
        btn.disabled = history.length <= 1; 
    }


    // --- 2. FUNKCE PRO KRESLEN칈 (Vykresl칤 v코e znovu a znovu) ---
    function drawGraph() {
        // Vy캜istit pl치tno
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // A) Kreslen칤 hran (hotov칳ch)
        ctx.lineWidth = 3;
        ctx.strokeStyle = EDGE_COLOR;
        
        edges.forEach(edge => {
            const start = nodes.find(n => n.id === edge.from);
            const end = nodes.find(n => n.id === edge.to);
            if (start && end) {
                ctx.beginPath();
                ctx.moveTo(start.x, start.y);
                ctx.lineTo(end.x, end.y);
                ctx.stroke();
            }
        });

        // B) Kreslen칤 pr치v캩 ta쬰n칠 캜치ry (pokud t치hnu)
        if (isDragging && dragStartNode) {
            ctx.beginPath();
            ctx.strokeStyle = HIGHLIGHT_COLOR;
            ctx.moveTo(dragStartNode.x, dragStartNode.y);
            ctx.lineTo(mouseX, mouseY);
            ctx.stroke();
        }

	// C) Kreslen칤 vrchol콢
    nodes.forEach(node => {
        ctx.beginPath();
        ctx.arc(node.x, node.y, NODE_RADIUS, 0, 2 * Math.PI);
        
        // ZV칗RAZN캨N칈: Pokud je uzel vybran칳, bude m칤t jinou barvu (nap콏. 캜ervenou)
        ctx.fillStyle = (selectedNode && node.id === selectedNode.id) ? HIGHLIGHT_COLOR : NODE_COLOR;
        
        ctx.fill();
        ctx.fillStyle = 'white';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(node.degree, node.x, node.y);
        ctx.stroke();
    });
}

let attemptCounter = 0; // Po캜칤tadlo pokus콢

    function addToHistory(success, message) {
        attemptCounter++;
        
        // 1. Vyfot칤me Canvas (z칤sk치me obr치zek jako textov칳 콏et캩zec)
        const dataUrl = canvas.toDataURL(); 

        // 2. P콏iprav칤me HTML pro jeden z치znam
        const statusClass = success ? 'status-ok' : 'status-fail';
        const statusText = success ? 'PASS' : 'FAIL';
        
        // 캛asov치 zna캜ka (pro realisti캜nost)
        const now = new Date();
        const timeString = now.toLocaleTimeString();

        const html = `
            <div class="history-item">
                <strong>Attempt No. ${attemptCounter}</strong> <small>(${timeString})</small><br>
                Result: <span class="${statusClass}">${statusText}</span><br>
                <small>${message}</small>
                <img src="${dataUrl}" class="history-img">
            </div>
        `;

        // 3. Vlo쮂셠e z치znam do prav칠ho panelu
        const list = document.getElementById('history-list');
        
        // Vlo쮂셠e nakonec (jako do chatu) - aby musel 쮂멺 scrollovat nahoru pro star코칤
        list.insertAdjacentHTML('beforeend', html);

        // Automaticky odscrollovat dol콢 na nov칳 v칳sledek
        list.scrollTop = list.scrollHeight;
    }

	// --- POMOCN칄 FUNKCE PRO INTERAKCI ---

// 1. Funkce, kter치 zjist칤, zda je na dan칳ch sou콏adnic칤ch uzel
function getNodeAtPos(x, y) {
    // Projdeme v코echny uzly a zkus칤me, jestli x,y le쮂 uvnit콏 kruhu uzlu
    return nodes.find(node => {
        const dx = node.x - x;
        const dy = node.y - y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance < NODE_RADIUS + 5; // Mal치 rezerva pro snaz코칤 trefen칤 na mobilu
    });
}

// 2. Funkce pro vykreslen칤 (ujist캩te se, 쬰 pou쮂셨치 selectedNode pro zv칳razn캩n칤)
function drawGraph() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Kreslen칤 hran
    ctx.lineWidth = 3;
    ctx.strokeStyle = EDGE_COLOR;
    edges.forEach(edge => {
        const start = nodes.find(n => n.id === edge.from);
        const end = nodes.find(n => n.id === edge.to);
        if (start && end) {
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(end.x, end.y);
            ctx.stroke();
        }
    });

    // Kreslen칤 vrchol콢
    nodes.forEach(node => {
        ctx.beginPath();
        ctx.arc(node.x, node.y, NODE_RADIUS, 0, 2 * Math.PI);
        
        // Pokud je uzel vybran칳 (캜ek치 na spojen칤), zm캩n칤 barvu
        ctx.fillStyle = (selectedNode && node.id === selectedNode.id) ? HIGHLIGHT_COLOR : NODE_COLOR;
        
        ctx.fill();
        ctx.fillStyle = 'white';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(node.degree, node.x, node.y);
        ctx.strokeStyle = '#2c3e50';
        ctx.lineWidth = 1;
        ctx.stroke();
    });
}

// --- 3. UPRAVEN츼 FUNKCE PRO INTERAKCI (pro PC i MOBIL) ---

canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const clickedNode = getNodeAtPos(x, y);

    if (clickedNode) {
        // SC칄N츼콎 A: Klikli jsme na uzel
        if (selectedNode === null) {
            // Prvn칤 kliknut칤: Vybereme uzel
            selectedNode = clickedNode;
            logAction('select_node', { node_id: clickedNode.id });
        } else if (selectedNode.id === clickedNode.id) {
            // Kliknut칤 na ten sam칳 uzel: Zru코칤me v칳b캩r
            selectedNode = null;
            logAction('deselect_node', { node_id: clickedNode.id });
        } else {
            // Kliknut칤 na druh칳 (jin칳) uzel: Vytvo콏칤me/Sma쬰me hranu
            const fromId = selectedNode.id;
            const toId = clickedNode.id;

            const existingEdgeIndex = edges.findIndex(edge => 
                (edge.from === fromId && edge.to === toId) ||
                (edge.from === toId && edge.to === fromId)
            );

            if (existingEdgeIndex !== -1) {
                edges.splice(existingEdgeIndex, 1);
                logAction('change_edge', { edge_action: 'removed', from: fromId, to: toId });
            } else {
                edges.push({ from: fromId, to: toId });
                logAction('change_edge', { edge_action: 'added', from: fromId, to: toId });
            }

            updateNodeDegrees();
            saveState();
            selectedNode = null; // Po spojen칤 zru코칤me v칳b캩r
        }
    } else {
        // SC칄N츼콎 B: Klikli jsme do pr치zdna
        if (selectedNode !== null) {
            // Pokud jsme m캩li vybran칳 uzel, kliknut칤m do pr치zdna v칳b캩r zru코칤me
            selectedNode = null;
        } else {
            // Vytvo콏칤me nov칳 uzel
            const newNode = {
                id: nodes.length > 0 ? Math.max(...nodes.map(n => n.id)) + 1 : 1,
                x: x,
                y: y,
                degree: 0 
            };
            nodes.push(newNode);
            saveState();
            logAction('add_node', { node_id: newNode.id });
        }
    }
    drawGraph();
});


// Smazat v코e
    function clearGraph() {
        nodes = [];
        edges = [];
        updateNodeDegrees(); 
        saveState(); 
        drawGraph();
	logAction('clear_graph');
        previousGraphState = { nodesCount: 0, edgesCount: 0 };
    }    


// Pomocn치 funkce: Znovu p콏epo캜칤t치 stupe켿 pro ka쬯칳 vrchol
    function updateNodeDegrees() {
        // Nejprve vynulujeme v코echny stupn캩
        nodes.forEach(n => n.degree = 0);
        
        // Pak projdeme v코echny hrany a zv칳코칤me stupe켿 u obou konc콢
        edges.forEach(edge => {
            const nodeFrom = nodes.find(n => n.id === edge.from);
            const nodeTo = nodes.find(n => n.id === edge.to);

            if (nodeFrom) nodeFrom.degree++;
            if (nodeTo) nodeTo.degree++;
        });
    }

// --- 4. LOGIKA (Matematika Eulerovsk칳ch tah콢) - BEZ VYSKAKOVAC칈CH OKEN ---

    function testGraph() {
        // 1. Pojistka: Pr치zdn칳 graf
        if (nodes.length < 2 || edges.length === 0) {
            alert("Draw at least two nodes and one line.");
            logAction('test_graph', { result: 'fail', reason: 'empty_graph' });
            return;
        }

        // 2. Spo캜칤tat stupn캩 vrchol콢
        let degrees = {};
        nodes.forEach(n => degrees[n.id] = 0);

        edges.forEach(edge => {
            degrees[edge.from]++;
            degrees[edge.to]++;
        });

        // --- KONTROLA: IZOLOVAN칄 BODY ---
        let isolatedNodes = nodes.filter(n => degrees[n.id] === 0);
        
        if (isolatedNodes.length > 0) {
            logAction('test_graph', { result: 'fail', reason: 'isolated_node' });
            lastTestTimestamp = Date.now();
            
            // Fotka pro report
            const imgData = canvas.toDataURL(); 
            logAction('test_graph_fail_snapshot', { img_snapshot: imgData });
            addToHistory(false, "");
            return;
        }

        // 3. Zjistit po캜et vrchol콢 s lich칳m stupn캩m
        let oddVerticesCount = 0;
        for (let id in degrees) {
            if (degrees[id] % 2 !== 0) {
                oddVerticesCount++;
            }
        }

        // 4. Kontrola souvislosti
        if (!isGraphConnected(degrees)) {
            const imgData = canvas.toDataURL();
            logAction('test_graph', { 
                result: 'fail', 
                reason: 'disconnected',
                img_snapshot: imgData 
            });
            lastTestTimestamp = Date.now(); 
            addToHistory(false, "");
            return;
        }

        // 5. Vyhodnocen칤 podle Eulera
        let success = (oddVerticesCount === 0 || oddVerticesCount === 2);
        let msg = "";

        if (success) {
            msg = oddVerticesCount === 0 ? "" : "";
        } else {
            msg = ``;
        }

        // --- M캨콎EN칈 VOTAT ---
        let currentGraphState = { nodesCount: nodes.length, edgesCount: edges.length };
        let nodeDiff = Math.abs(currentGraphState.nodesCount - previousGraphState.nodesCount);
        let edgeDiff = Math.abs(currentGraphState.edgesCount - previousGraphState.edgesCount);
        
        let votat_applied = (nodeDiff === 0 && edgeDiff === 1) || (edgeDiff === 0 && nodeDiff === 1);
        
        // FOTKA PRO LOG
        const imgData = canvas.toDataURL(); 

        // Ulo쬴t do historie (vizu치ln칤 panel)
        addToHistory(success, msg);
        
        // LOGOV츼N칈 DO SOUBORU
        logAction('test_graph', { 
            result: success ? 'pass' : 'fail', 
            votat: votat_applied, 
            node_diff: nodeDiff,
            edge_diff: edgeDiff,
            img_snapshot: imgData 
        });

        lastTestTimestamp = Date.now();
        previousGraphState = currentGraphState; 
    }

    // Pomocn치 funkce: Zkontroluje, zda se z jednoho bodu dostaneme do v코ech ostatn칤ch
    function isGraphConnected(degrees) {
        // Najdeme v코echny body, kter칠 maj칤 alespo켿 jednu hranu
        let activeNodeIds = nodes.filter(n => degrees[n.id] > 0).map(n => n.id);
        
        if (activeNodeIds.length === 0) return true; // 콯치dn칠 hrany = technicky spojeno

        // Za캜neme prohled치vat od prvn칤ho aktivn칤ho bodu
        let startId = activeNodeIds[0];
        let visited = new Set();
        let queue = [startId];

        while (queue.length > 0) {
            let currentId = queue.shift();
            if (visited.has(currentId)) continue;
            visited.add(currentId);

            // Najdeme sousedy
            edges.forEach(edge => {
                if (edge.from === currentId && !visited.has(edge.to)) queue.push(edge.to);
                if (edge.to === currentId && !visited.has(edge.from)) queue.push(edge.from);
            });
        }

        // Pokud jsme nav코t칤vili v코echny aktivn칤 body, je graf spojen칳
        return activeNodeIds.every(id => visited.has(id));
    }

// --- M캨콎EN칈 SCROLLINGU (MONITOROV츼N칈) ---
    const historyList = document.getElementById('history-list');
    let scrollStartTimestamp = 0;

    historyList.addEventListener('scroll', () => {
        // Logov치n칤 startu scrollov치n칤
        if (scrollStartTimestamp === 0) {
            scrollStartTimestamp = Date.now();
            logAction('scroll_start');
        }
        // P콏i ka쬯칠m scrollu nastav칤me timeout, aby se 'scroll_end' logoval a po pauze.
        clearTimeout(historyList.scrollTimeout);
        historyList.scrollTimeout = setTimeout(() => {
            if (scrollStartTimestamp !== 0) {
                const duration = Date.now() - scrollStartTimestamp;
                logAction('scroll_end', { duration_ms: duration });
                scrollStartTimestamp = 0;
            }
        }, 300); // 300 ms pauza na to, aby se to pova쬺valo za konec scrollov치n칤
    });

// --- 5. INICIALIZACE ---

    // Prvn칤 ulo쬰n칤 stavu a vypnut칤 tla캜칤tka Undo
    saveState();

// --- FUNKCE PRO EXPORT DAT (CSV - 캛ist치 data pro Excel/SPSS) ---
    function exportLog() {
        if (metacognitionLog.length === 0) {
            alert("Nem치m 쮂멳n치 data, otestujte alespo켿 jeden obr치zek.");
            return;
        }

        // Definujeme sloupce, kter칠 chceme v Excelu (po콏ad칤)
        const columns = ['timestamp', 'action', 'result', 'thinktime_ms', 'votat', 'nodes_count', 'edges_count', 'duration_ms'];
        const header = columns.join(';');

        const csvRows = metacognitionLog.map(row => {
            return columns.map(col => {
                let val = row[col];
                // Pokud hodnota neexistuje, nech치me pr치zdn칠
                if (val === undefined || val === null) return "";
                // Nahrad칤me te캜ky za 캜치rky u 캜칤sel (pro 캜esk칳 Excel), pokud je pot콏eba
                return String(val);
            }).join(';');
        });

        const finalCsv = [header, ...csvRows].join('\n');

        // Sta쬰n칤
        const blob = new Blob(["\ufeff", finalCsv], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = "data_metakognice_" + Date.now() + ".csv";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }


// --- FUNKCE PRO VIZU츼LN칈 REPORT S OBR츼ZKY (HTML) ---
    function exportVisualReport() {
        if (metacognitionLog.length === 0) {
            alert("Nem치m 쮂멳n치 data, otestuje alespo켿 jeden obr치zek.");
            return;
        }

        let htmlContent = `
        <html>
        <head>
            <meta charset='utf-8'>
            <title>Vizu치ln칤 Report Metakognice</title>
            <style>
                body { font-family: sans-serif; padding: 20px; }
                table { border-collapse: collapse; width: 100%; }
                th, td { border: 1px solid #ddd; padding: 8px; text-align: left; vertical-align: top; }
                th { background-color: #f2f2f2; }
                .img-cell img { width: 150px; border: 1px solid #999; }
                .pass { color: green; font-weight: bold; }
                .fail { color: red; font-weight: bold; }
            </style>
        </head>
        <body>
            <h2>Report pr콢chodu 쮂멺a</h2>
            <p>Datum: ${new Date().toLocaleString()}</p>
            <table>
                <tr>
                    <th>캛as</th>
                    <th>Akce</th>
                    <th>Detaily (Thinktime, VOTAT)</th>
                    <th>Sn칤mek grafu</th>
                </tr>
        `;

        // Projdeme log a vytvo콏칤me 콏치dky tabulky
        metacognitionLog.forEach(row => {
            const time = new Date(row.timestamp).toLocaleTimeString();
            let details = "";
            let imageHtml = "";

            // Form치tov치n칤 detail콢 do 캜iteln칠 podoby
            if (row.thinktime_ms) details += `<strong>Thinktime:</strong> ${row.thinktime_ms} ms<br>`;
            if (row.action === 'test_graph') {
                details += `Result: <span class="${row.result}">${row.result}</span><br>`;
                details += `VOTAT: ${row.votat ? 'ANO' : 'NE'}<br>`;
            }
            if (row.action === 'scroll_end') details += `D칠lka scrollov치n칤: ${row.duration_ms} ms`;

            // Pokud z치znam obsahuje fotku, zobraz칤me ji
            if (row.img_snapshot) {
                imageHtml = `<img src="${row.img_snapshot}">`;
            }

            htmlContent += `
                <tr>
                    <td>${time}</td>
                    <td>${row.action}</td>
                    <td>${details}</td>
                    <td class="img-cell">${imageHtml}</td>
                </tr>
            `;
        });

        htmlContent += `</table></body></html>`;

        // Sta쬰n칤 souboru
        const blob = new Blob([htmlContent], { type: 'text/html' });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = "vizualni_report_" + Date.now() + ".html";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

</script>

</body>

</html>








